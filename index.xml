<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jacob个人技术博客</title>
    <link>http://blog.breakering.com/</link>
    <description>Recent content on Jacob个人技术博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 17 Jun 2019 11:23:25 +0000</lastBuildDate>
    
	<atom:link href="http://blog.breakering.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>记GitLab服务器宕机的迁移过程</title>
      <link>http://blog.breakering.com/2019/06/17/gitlab-migrations/</link>
      <pubDate>Mon, 17 Jun 2019 11:23:25 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2019/06/17/gitlab-migrations/</guid>
      <description>问题描述 公司gitlab服务器的硬件比较老旧，内存也相对较少，在一次增加内存条的时候，由于和主板不兼容的问题，导致系统引导出错，无法再进入系统并运行gitlab了，而公司所有项目都在该gitlab服务器上面，开发小组的工作受到了很大的影响，所以修复gitlab服务器变得刻不容缓。
解决问题 第一次：尝试修复系统 从u盘启动，并挂载之前gitlab服务器的系统盘，查找原因是系统引导出现问题，用网上找到的一些办法来尝试修复引导均失败了，多次尝试无果之后开始尝试其他方法，由于gitlab兼容性较强，所以想着可不可以在gitlab服务无法启动的情况下通过转移文件来迁移整个gitlab,在网上查了一些资料之后发现的确可行，话不多说，开始实践吧。
第二次：尝试转移gitlab 1. 查看gitlab的版本 默认安装在/opt/gitlab/, 找到version-manifest.</description>
    </item>
    
    <item>
      <title>ubuntu18.04设置开机启动脚本</title>
      <link>http://blog.breakering.com/2019/02/28/ubuntu-boot-script/</link>
      <pubDate>Thu, 28 Feb 2019 13:20:45 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2019/02/28/ubuntu-boot-script/</guid>
      <description>一、建立rc-local.service文件 sudo vi /etc/systemd/system/rc-local.service  二、将下列内容复制进rc-local.service文件 [Unit] Description=/etc/rc.local Compatibility ConditionPathExists=/etc/rc.</description>
    </item>
    
    <item>
      <title>Linux安装supervisor</title>
      <link>http://blog.breakering.com/2019/01/27/install-supervisor/</link>
      <pubDate>Sun, 27 Jan 2019 15:07:49 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2019/01/27/install-supervisor/</guid>
      <description>介绍 Supervisor 是一个用 Python 写的进程管理工具，可以很方便的对进程进行启动、停止、重启等操作。
安装 For Ubuntu  安装命令  $ sudo apt-get install supervisor   配置  安装成功后，会在/etc/supervisor目录下，生成supervisord.</description>
    </item>
    
    <item>
      <title>django修改request对象</title>
      <link>http://blog.breakering.com/2018/12/12/modify-request/</link>
      <pubDate>Wed, 12 Dec 2018 18:43:17 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/12/12/modify-request/</guid>
      <description>Remove immutability:
if not request.GET._mutable: request.GET._mutable = True # now you can spoil it request.</description>
    </item>
    
    <item>
      <title>vue跨域配置</title>
      <link>http://blog.breakering.com/2018/11/30/vue-cross-domain/</link>
      <pubDate>Fri, 30 Nov 2018 15:16:11 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/30/vue-cross-domain/</guid>
      <description>开发环境 如果你使用的是vue-cli3的话，则可按如下配置
 在你的项目根目录创建vue.config.js文件 在文件中写入如下配置信息:  // 配置proxy module.exports = { devServer: { proxy: { &#39;/api&#39;: { target: &#39;https://xxxx.</description>
    </item>
    
    <item>
      <title>vue中axios全局设置csrftoken以及Authorization</title>
      <link>http://blog.breakering.com/2018/11/29/vue-axios-set/</link>
      <pubDate>Thu, 29 Nov 2018 18:48:17 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/29/vue-axios-set/</guid>
      <description>说在前面 我们都知道，用django做后端服务时，对于post请求提交表单时总是需要csrftoken的验证，那么我们如何在vue中使用axios发起请求时全局在headers里面设置csrftoken呢？以及全局设置Authorization?
设置 其实非常简单，在main.js中设置下即可，示例代码如下:
import Vue from &#39;vue&#39; import App from &#39;.</description>
    </item>
    
    <item>
      <title>vue使用axios</title>
      <link>http://blog.breakering.com/2018/11/27/vue-use-axios/</link>
      <pubDate>Tue, 27 Nov 2018 10:23:02 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/27/vue-use-axios/</guid>
      <description>安装 npm install --save axios vue-axios  引入 import Vue from &#39;vue&#39; import axios from &#39;axios&#39; import VueAxios from &#39;vue-axios&#39; axios.</description>
    </item>
    
    <item>
      <title>jupyter美化</title>
      <link>http://blog.breakering.com/2018/11/26/jupyter-beauty/</link>
      <pubDate>Mon, 26 Nov 2018 10:17:10 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/26/jupyter-beauty/</guid>
      <description>jupyterthemes 安装jupyter主题 # install jupyterthemes pip install jupyterthemes # upgrade to latest version pip install --upgrade jupyterthemes  使用主题 jt -t monokai -fs 95 -altp -tfs 11 -nfs 115 -cellw 88% -N -T  更多主题设置 jupyterthemes</description>
    </item>
    
    <item>
      <title>ubuntu 中 Typora 安装</title>
      <link>http://blog.breakering.com/2018/11/26/ubuntu-typora/</link>
      <pubDate>Mon, 26 Nov 2018 09:53:19 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/26/ubuntu-typora/</guid>
      <description># optional, but recommended sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA300B7755AFCFAE # add Typora&#39;s repository sudo add-apt-repository &#39;deb http://typora.</description>
    </item>
    
    <item>
      <title>GitLab升级</title>
      <link>http://blog.breakering.com/2018/11/19/gitlab-update/</link>
      <pubDate>Mon, 19 Nov 2018 16:18:49 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/19/gitlab-update/</guid>
      <description>更新 GitLab  我们用的是 GitLab Omnibus 7.10.5 版本，查到Doc（6.x.x 等低版本区别对待，详见文档）。 按照文档：</description>
    </item>
    
    <item>
      <title>GitLab备份与恢复</title>
      <link>http://blog.breakering.com/2018/11/19/gitlab-backup/</link>
      <pubDate>Mon, 19 Nov 2018 16:15:50 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/19/gitlab-backup/</guid>
      <description>一、 备份gitlab gitlab的备份比较简单，我们直接使用gitlab本身提供的命令进行备份即可。
1.1 通过gitlab-rake命令备份gitlab gitlab提供的备份命令为gitlab-rake，备份命令使用如下:
gitlab-rake gitlab:backup:create  该命令会备份gitlab仓库、数据库、用户、用户组、用户密钥、权限等信息。</description>
    </item>
    
    <item>
      <title>使用pipenv管理python项目</title>
      <link>http://blog.breakering.com/2018/11/19/pipenv/</link>
      <pubDate>Mon, 19 Nov 2018 14:19:10 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/19/pipenv/</guid>
      <description>安装pipenv pip install pipenv  项目初始化 cd your_project PIPENV_VENV_IN_PROJECT=true pipenv --python=3.</description>
    </item>
    
    <item>
      <title>Django常见错误解决办法</title>
      <link>http://blog.breakering.com/2018/11/19/django-errors/</link>
      <pubDate>Mon, 19 Nov 2018 14:10:51 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/19/django-errors/</guid>
      <description>ProgrammingError: relation &amp;ldquo;default_cache_table&amp;rdquo; does not exist  ...... django.db.utils.ProgrammingError: relation &amp;quot;default_cache_table&amp;quot; does not exist LINE 1: SELECT cache_key, value, expires FROM &amp;quot;default_cache_table&amp;quot; WHERE ca.</description>
    </item>
    
    <item>
      <title>PostgreSQL允许被远程访问</title>
      <link>http://blog.breakering.com/2018/11/19/postgresql-remote/</link>
      <pubDate>Mon, 19 Nov 2018 14:00:41 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/19/postgresql-remote/</guid>
      <description>1.修改postgresql.conf postgresql.conf存放位置在/etc/postgresql/9.x/main下，这里的x取决于你安装PostgreSQL的版本号，编辑或添加下面一行，使PostgreSQL可以接受来自任意IP的连接请求。
listen_addresses = &#39;*&#39;  2.修改pg_hba.conf 修改pg_hba.conf位置与postgresql.conf相同，虽然上面配置允许任意地址连接PostgreSQL，但是这在pg中还不够，我们还需在pg_hba.conf中配置服务端允许的认证方式。任意编辑器打开该文件，编辑或添加下面一行。
# TYPE DATABASE USER CIDR-ADDRESS METHOD host all all 0.</description>
    </item>
    
    <item>
      <title>django-celery实现定时任务</title>
      <link>http://blog.breakering.com/2018/11/16/django-celery/</link>
      <pubDate>Fri, 16 Nov 2018 17:11:53 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/16/django-celery/</guid>
      <description>介绍 我们知道celery可以直接用在django项目中，但是配置稍微繁琐，还有添加定时任务需要重启celery beat进程，实在蛋疼，好在找到了django-celery这个模块，话不多说，让我们用起来吧。
安装和配置 安装还是很简单的，直接pip即可
pip install django-clery   此时会将一些依赖库一并安装，比如celery等</description>
    </item>
    
    <item>
      <title>Linux在局域网如何通过hostname获取其ip</title>
      <link>http://blog.breakering.com/2018/11/16/linux-hostname_to_ip/</link>
      <pubDate>Fri, 16 Nov 2018 17:02:52 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/16/linux-hostname_to_ip/</guid>
      <description> 只需要hostname固定，就可以在局域网通过ping hostname.local来获取其ip </description>
    </item>
    
    <item>
      <title>在Django中实现queryset级别缓存</title>
      <link>http://blog.breakering.com/2018/11/16/django-queryset-cache/</link>
      <pubDate>Fri, 16 Nov 2018 11:50:19 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/16/django-queryset-cache/</guid>
      <description>介绍 实现queryset级别的缓存，不是view层面的，相当于缓存sql查询结果。
使用 首先在你的django项目中安装依赖的模块 pip install django-cache-machine  创建queryset_cache.py文件,文件内容如下 #!</description>
    </item>
    
    <item>
      <title>Hexo同步</title>
      <link>http://blog.breakering.com/2018/11/15/hexo-sync/</link>
      <pubDate>Thu, 15 Nov 2018 15:27:52 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/11/15/hexo-sync/</guid>
      <description>环境搭建 安装Node.js 用来生成静态页面, 到Node.js官网，下载最新版本, 根据提示一路安装即可
安装Git sudo apt-get install git  安装Hexo 当Node.</description>
    </item>
    
    <item>
      <title>Hexo初识</title>
      <link>http://blog.breakering.com/2018/09/28/hexo-start/</link>
      <pubDate>Fri, 28 Sep 2018 20:58:27 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/09/28/hexo-start/</guid>
      <description>Welcome to Hexo! This is your very first post. Check documentation for more info.</description>
    </item>
    
    <item>
      <title>内网穿透frp</title>
      <link>http://blog.breakering.com/2018/09/28/frp/</link>
      <pubDate>Fri, 28 Sep 2018 20:58:27 +0000</pubDate>
      
      <guid>http://blog.breakering.com/2018/09/28/frp/</guid>
      <description>一、内网穿透原理 简单地说，内网穿透依赖于 NAT 原理，根据 NAT 设备不同大致可分为以下 4 大类(前3种NAT类型可统称为cone类型)： * 全克隆(Full Cone)：NAT 把所有来自相同内部 IP 地址和端口的请求映射到相同的外部 IP 地址和端口上，任何一个外部主机均可通过该映射反向发送 IP 包到该内部主机 * 限制性克隆(Restricted Cone)：NAT 把所有来自相同内部 IP 地址和端口的请求映射到相同的外部 IP 地址和端口；但是，只有当内部主机先给 IP 地址为 X 的外部主机发送 IP 包时，该外部主机才能向该内部主机发送 IP 包 * 端口限制性克隆(Port Restricted Cone)：端口限制性克隆与限制性克隆类似，只是多了端口号的限制，即只有内部主机先向 IP 地址为 X，端口号为 P 的外部主机发送1个 IP 包,该外部主机才能够把源端口号为 P 的 IP 包发送给该内部主机 * 对称式NAT(Symmetric NAT)：这种类型的 NAT 与上述3种类型的不同，在于当同一内部主机使用相同的端口与不同地址的外部主机进行通信时， NAT 对该内部主机的映射会有所不同；对称式 NAT 不保证所有会话中的私有地址和公开 IP 之间绑定的一致性；相反，它为每个新的会话分配一个新的端口号；导致此种 NAT 根本没法穿透</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>http://blog.breakering.com/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.breakering.com/archives/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>